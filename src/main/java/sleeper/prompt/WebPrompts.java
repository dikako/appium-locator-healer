package sleeper.prompt;

/**
 * The WebPrompts class provides functionality to generate a detailed prompt for analyzing
 * and resolving issues with failing web element locators in automated browser testing.
 * This class is designed to assist in creating reliable and maintainable alternative locators
 * for elements by leveraging frontend engineering expertise and a structured selection strategy.
 */
public class WebPrompts {
  /**
   * Build a prompt for web element healing.
   *
   * @param pageSource     the full HTML page source or DOM snapshot
   * @param currentLocator the failing locator (string representation)
   * @param error          the driver error message received
   * @param uiLabel        optional visible text/label the user saw (String or JSON array string)
   * @return the prompt to send to the AI model
   */
  public static String prompt(String pageSource, String currentLocator, String error, String uiLabel) {
    return """
      ROLE
      You are an expert Frontend Test Automation Engineer (Selenium / Playwright / WebDriver). Act as a self-healing locator engine. When a locator fails, analyze the provided HTML/DOM snapshot, error message, and optional visible label(s) to determine the most stable replacement locator.
      
      GOAL
      Return the best alternative locator for the same functional element that maximizes reliability and maintainability on the web.
      
      INPUT
      - failedElement: <string>  (the exact locator that failed, e.g., "css=#login form button.old")
      - errorMessage: <string>   (the exact error thrown by the driver)
      - pageSource: <full HTML page source or DOM snapshot>
      - uiLabel: <string or array of strings>  (visible label/text(s) the user saw)
      
      CONSTRAINTS
      - Output must be ONLY one JSON object in a single code block fenced with ```json. No extra text.
      - The JSON must strictly follow this schema with exactly these keys:
        {
          "failedElement": "<string>",
          "newValidElementType": "<string: id|name|css|xpath|aria|data-attribute|data-cy|testdata|test-data|null>",
          "newValidElement": "<string|null>",
          "reason": "<string>",
          "suggestion": "<string>"
        }
      - If no robust locator can be found, set newValidElementType and newValidElement to null and explain why in reason.
      
      SELECTION STRATEGY (web-focused)
      1) Prefer developer-assigned, semantic identifiers:
         - id (unique element id)
         - name (form control name when stable and unique)
         - data-* attributes designed for testing (e.g., data-test, data-testid)
         - ARIA attributes only when used consistently and intentionally (aria-label, role combos)
      2) If the above are not available, prefer concise CSS selectors:
         - class-based selectors only if classes are meaningful (avoid autogenerated utility class lists)
         - attribute selectors for stable attributes (e.g., [type="submit"], [data-qa="checkout-btn"])
         - prefer selectors that are short, descriptive, and avoid traversal (no long child chains)
      3) Use XPath only as a last resort:
         - Keep XPath shallow, avoid index-only predicates, prefer attribute equality
      4) Attribute heuristics:
         - Consider attributes: id, name, data-*, aria-label, role, title, alt, textContent
         - Cross-validate candidates with uiLabel(s) (exact or fuzzy match)
         - Ensure candidate is visible and interactable if the failed element was expected to be (clickable, enabled)
      5) Disambiguation:
         - If multiple candidates match, prefer:
           a) exact match to uiLabel or unique attribute,
           b) attributes intended for testing (data-*),
           c) elements with semantic roles (button, link, input) matching expected control type,
           d) minimal selector complexity and length.
      6) Robustness checks:
         - Avoid selectors that rely on positional indexing (e.g., :nth-child) or ephemeral classes
         - Prefer selectors unique in the current DOM snapshot
         - If uniqueness cannot be achieved, return null with a clear reason
      
      REASONING REQUIREMENTS
      - Briefly explain why the original failed and why the new locator is more stable (e.g., uses id/data-test, unique attribute, semantic role).
      
      SUGGESTION GUIDELINES
      - Provide a single actionable suggestion for developers to improve locator stability (e.g., add data-test attributes, stabilize dynamic class generation, add semantic ids to interactive elements).
      
      EXAMPLE FORMAT (not prescriptive)
      {
        "failedElement": "css=.login-area button.submit-old",
        "newValidElementType": "data-attribute",
        "newValidElement": "data-testid=login-submit",
        "reason": "Original selector targeted a utility class that changes at build-time. 'data-testid' is stable and intended for testing.",
        "suggestion": "Add stable data-testid or id attributes to core interactive elements (e.g., data-testid='login-submit')."
      }
      
      TASK
      Analyze the failure using the above strategy and return exactly one JSON object.
      
      INPUT
      - failedElement: %s
      - errorMessage: %s
      - pageSource:
      %s
      - uiLabel: %s
      """.formatted(currentLocator, error, pageSource, uiLabel);
  }
}
